display.c:54:		if (algo->flag == 2 || algo->flag == 3)
display.c:58:			else if (ghost[curr_ant].path[ghost[curr_ant].i] == algo->index_end)
display.c:68:		if (algo->flag == 2 || algo->flag == 3)
ft_best_path.c:41:	if ((ant[curr_ant].coup + room[best].power - 1 >= algo->lesscoup + 1) && best != algo->index_end)
ft_best_path.c:61:	if (curr == algo->index_start)
ft_best_path.c:102:	lesslink = room[algo->index_start].links > room[algo->index_end].links ? room[algo->index_end].links : room[algo->index_start].links;
ft_best_path.c:105:		room[algo->index_start].pass = 1;
ft_best_path.c:107:		ant[curr_ant].curr = algo->index_start;
ft_best_path.c:110:			if (ant[curr_ant].curr != algo->index_end)
ft_best_path.c:123:				if (ant[curr_ant].coup == algo->lesscoup + 1)
ft_best_path.c:129:				if (algo->lesscoup == ant[curr_ant].coup)
ft_best_path.c:131://					printf("j4qi trouver un chemic cool %d\n", algo->lesscoup);
ft_best_path.c:132:					if (curr_ant != 0 || all->fourmis == 1 || algo->lesscoup == 1)
ft_best_path.c:149:			algo->lesscoup++;
ft_best_path.c:189:	room[algo->index_start].pass = 1;
ft_best_path.c:190:	if (room[algo->index_start].links == 0)
ft_best_path.c:192:	algo->lesscoup = room[room[algo->index_start].index[0]].power;
ft_best_path.c:197:							* (algo->lesscoup + 1000))))
ft_best_path.c:199:		ft_init_db_int(room[i].coup, algo->lesscoup + 1000);
ft_print_ant_path.c:40:	algo->step = 1;
ft_print_ant_path.c:44:	room[algo->index_end].slot = 0;
ft_print_ant_path.c:45:	room[algo->index_start].slot = all->fourmis;
ft_print_ant_path.c:46:	while (room[algo->index_end].slot != all->fourmis)
ft_print_ant_path.c:49://		ft_putnbr(room[algo->index_end].slot);
ft_print_ant_path.c:52:		if (algo->flag == 1 || algo->flag == 3)
ft_print_ant_path.c:53:			ft_color(algo->step, 0);
ft_print_ant_path.c:65:						if (ant[i].path[ant[i].i] == algo->index_end)
ft_print_ant_path.c:66:							room[algo->index_end].slot++;
ft_print_ant_path.c:80:		algo->step++;
main.c:76:	algo->flag = 0;
main.c:87:				algo->flag += 2;
main.c:89:				algo->flag += 1;
parser_2.c:23:			algo->index_start = i;
parser_2.c:25:			algo->index_end = i;
power.c:19:	algo->list2[cmt] = -42;
power.c:21:	while (algo->list2[i] != -42)
power.c:23:		algo->list1[i] = algo->list2[i];
power.c:26:	algo->list1[i] = -42;
power.c:49:	algo->courant = 0;
power.c:54:		while (algo->list1[i] != -42)
power.c:57:			while (++j < room[algo->list1[i]].links)
power.c:59:				if (room[algo->list1[i]].index[j] == algo->index_end && room[algo->list1[i]].courant == INT_MAX)
power.c:61:					room[room[algo->list1[i]].index[j]].previous = algo->list1[i];
power.c:64:				if (room[room[algo->list1[i]].index[j]].power == 0 && room[algo->list1[i]].index[j] != algo->index_end && (!(room[algo->list1[i]].prev == 1 && room[room[algo->list1[i]].index[j]].courant == INT_MAX)))
power.c:66:								//		printf("Je suis ici %s et je veux aller %s\n J'ai un courant de %d et il a un courant de %d\n", room[algo->list1[i]].name, room[room[algo->list1[i]].index[j]].name, room[algo->list1[i]].courant, room[room[algo->list1[i]].index[j]].courant);
power.c:67:						if (room[algo->list1[i]].courant == INT_MAX || room[algo->list1[i]].courant <= room[room[algo->list1[i]].index[j]].courant)
power.c:69:							room[room[algo->list1[i]].index[j]].power = 1;
power.c:70:							algo->list2[cmt] = room[algo->list1[i]].index[j];
power.c:71:							if (room[room[algo->list1[i]].index[j]].courant == INT_MAX)
power.c:72:								room[room[algo->list1[i]].index[j]].previous = algo->list1[i];
power.c:74:								room[room[algo->list1[i]].index[j]].prev = room[algo->list1[i]].prev + 1;
power.c:88:	if (!(algo->list1 = (int*)malloc(sizeof(int) * (all->room))))
power.c:90:	if (!(algo->list2 = (int*)malloc(sizeof(int) * (all->room))))
power.c:92:	algo->list1[0] = algo->index_start;
power.c:93:	algo->list1[1] = -42;
power.c:94:	algo->step = 1;
power.c:95:	room[algo->index_start].power = 1;
power.c:110:	room[algo->index_start].power = 1;
power.c:111:	algo->list1[0] = algo->index_start;
power.c:112:	algo->list1[1] = -42;
power.c:122:	lesslink = room[algo->index_start].links > room[algo->index_end].links ? room[algo->index_end].links : room[algo->index_start].links;
power.c:218:	curr = algo->index_end;
power.c:219:	while (curr != algo->index_start)
power.c:224:		if (room[curr].courant != INT_MAX && curr != algo->index_start)
power.c:233:		if (k + 1 == algo->lesslink)
power.c:241:	algo->k = k;
power.c:255:	while (i <= algo->k)
power.c:264:		if (best > ((somme + algo->fourmis) / (float)way[i].nb_path) - 1)
power.c:266:			best = ((somme + algo->fourmis) / (float)way[i].nb_path) - 1;
power.c:289:	while (cmt < algo->fourmis)
power.c:329:		ant[curr_ant].curr = algo->index_start;
power.c:332:	room[algo->index_start].slot = all->fourmis;
power.c:333:	while (room[algo->index_end].slot != all->fourmis)
power.c:335:		if (algo->flag == 1 || algo->flag == 3)
power.c:336:			ft_color(algo->step, 0);
power.c:340:			if (ant[curr_ant].curr != algo->index_end)
power.c:342:				if (room[ant[curr_ant].path[ant[curr_ant].i]].slot == 0 || ant[curr_ant].path[ant[curr_ant].i] == algo->index_end)
power.c:351:		algo->step++;
power.c:363:	algo->fourmis = all->fourmis;
power.c:364:	algo->lesslink = room[algo->index_start].links > room[algo->index_end].links ? room[algo->index_end].links : room[algo->index_start].links;
tools.c:66:	if (!(algo->list1 = (int*)malloc(sizeof(int) * (room))))
tools.c:68:	if (!(algo->list2 = (int*)malloc(sizeof(int) * (room))))
tools.c:70:	algo->list1[0] = algo->index_end;
tools.c:71:	algo->list1[1] = -42;
